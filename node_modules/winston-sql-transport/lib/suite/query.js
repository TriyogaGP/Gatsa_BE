"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module 'query'
 * @fileoverview query test suite for winston-transport
 * @license MIT
 * @author Andrei Tretyakov <andrei.tretyakov@gmail.com>
 */
var assert_1 = require("assert");
var info = {
    level: 'debug',
    message: 'message',
};
exports.default = (function (transport) {
    describe('.query()', function () {
        it('should be present', function () {
            (0, assert_1.ok)(transport.query);
            (0, assert_1.strictEqual)('function', typeof transport.query);
        });
        it('should return matching results using default querying', function () {
            var callbackMock = jest.fn();
            transport.log(info, function () {
                transport.query({}, callbackMock);
                expect(callbackMock.mock.calls[0][0]).toBe(null);
                expect(callbackMock.mock.calls[0][1][0]).toHaveProperty('level');
                expect(callbackMock.mock.calls[0][1][0]).toHaveProperty('message');
                expect(callbackMock.mock.calls[0][1][0]).toHaveProperty('meta');
                expect(callbackMock.mock.calls[0][1][0]).toHaveProperty('timestamp');
            });
        });
        it('should return one result using the `rows` option', function () {
            var callbackMock = jest.fn();
            transport.log(info, function () {
                transport.query({ rows: 1 }, callbackMock);
                expect(callbackMock.mock.calls[0][0]).toBe(null);
                expect(callbackMock.mock.calls[0][1].length).toBe(1);
            });
        });
        it('should return matching results using `fields` and `order` option', function () {
            var callbackMock = jest.fn();
            transport.log(info, function () {
                transport.query({ fields: ['message', 'timestamp'], order: 'ASC' }, callbackMock);
                expect(callbackMock.mock.calls[0][0]).toBe(null);
                expect(callbackMock.mock.calls[0][1].length).toBe(3);
                expect(callbackMock.mock.calls[0][1][0]).not.toHaveProperty('level');
                expect(callbackMock.mock.calls[0][1][0]).toHaveProperty('message');
                expect(callbackMock.mock.calls[0][1][0]).not.toHaveProperty('meta');
                expect(callbackMock.mock.calls[0][1][0]).toHaveProperty('timestamp');
            });
        });
        it('should return matching results using the `from` and `until` option', function () {
            var callbackMock = jest.fn();
            transport.log(info, function () {
                var from = Date.now() - 100 * 1000;
                var until = Date.now() + 100 * 1000;
                transport.query({ from: from, until: until }, callbackMock);
                expect(callbackMock.mock.calls[0][1].length).toBe(4);
            });
        });
        it('should return no results using a bad `from` and `until` option', function () {
            var callbackMock = jest.fn();
            transport.log(info, function () {
                var bad = Date.now() + 1000000;
                transport.query({ from: bad, until: bad }, callbackMock);
                expect(callbackMock.mock.calls[0][1].length).toBe(0);
            });
        });
        afterAll(function () { return transport.flush(); });
    });
});
